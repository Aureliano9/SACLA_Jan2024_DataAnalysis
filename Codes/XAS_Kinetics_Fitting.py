# -*- coding: utf-8 -*-
"""
Created on Tue Aug 23 16:06:00 2022

@author: nurekeye

Fitting XAS Kinetics data from SACLA
csv files are generated by sorting code
lmfit package is used
"""

import time
start_time = time.time()
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import lmfit as lf
from scipy import special
from scipy.integrate import quad,quad_vec
from collections import defaultdict


#define functions for fitting
def custom_errfunc(x,x0,y0,a,g):
    return y0 + a*(1+ special.erf((x-x0) / (g/np.sqrt(2)) ) )

#exponent multiplied by Heviside function. While x0 in the exponent is unnecessary,
#it is easier to interpret fit results when it's there
def custom_exp_hevi(x,amp_exp,tau,x0):
    return amp_exp*np.exp(-(x-x0)/tau)*np.heaviside(x-x0,0.5)

#Sum of two exponents multiplied by Heviside function.
def custom_double_exp_hevi(x,amp_exp1,tau1,amp_exp2,tau2,x0):
    return ( (amp_exp1*np.exp(-(x)/tau1)) + (amp_exp2*np.exp(-(x)/tau2)) ) * np.heaviside(x-x0,1)

#Gaussian. Coefficient 2.3548200450309493 makues sure that width is equal to FWHM of a Gaussian,
#hence, to an FWHM of a derivative of a rise-time of a fitted function custom_conv()
def custom_gauss(x,amp_gauss,width):
    return amp_gauss * ( 1/( (width/2.3548200450309493)*np.sqrt(2*np.pi)) ) * np.exp( -((x)**2) / (2*((width/2.3548200450309493)**2) ) )


#Convolution of functions custom_exp_hevi() and custom_gauss(). Convolution is not evaluated over the whole time range.
#Expected rise time is about 300 fs, 
#so a Gaussian of such a width is almost fully defind within 10*width, i.e. within 3000 fs 
#(that's what k-1500,k+1500 refers to, k is the center of a Gaussion).
#Evaluating the convolution over the whole time range doesn't improve the result.
#Also,since bin size in data is 25 fs, the grid is 5 fs, that's where 601 comes from.

def custom_conv(x,x0,y0,amp_gauss,width,amp_exp,tau):
    res_f = [] #final convoluted function
    for xk in x: #
        res_t = [] #overlap between 2 functions at a single time-shift between them
        grid_x = np.linspace(xk-1500, xk+1500, 601) #set the grid over which to integrate
        f1 = custom_exp_hevi(grid_x,amp_exp,tau,x0)
        f2 = custom_gauss(xk-grid_x,amp_gauss,width)
        res_t=f1*f2 #mulitplication of 2 functions
        # integral = sum(res_t)
        integral = np.trapz( y=list(res_t), x=list(grid_x) ) #evaluating the integral
        res_f.extend([integral]) 
    return ( y0 + np.array(res_f) )

#Convolution of functions custom_double_exp_hevi() and custom_gauss()
def custom_conv2(x,x0,y0,amp_gauss,width,amp_exp1,tau1,amp_exp2,tau2):
    res_f = [] #final convoluted function 
    for xk in x: #
        res_t = [] #overlap between 2 functions at a single time-shift between them
        grid_x = np.linspace(xk-1500, xk+1500, 601) #set the grid over which to integrate
        f1 = custom_double_exp_hevi(grid_x,amp_exp1,tau1,amp_exp2,tau2,x0)
        f2 = custom_gauss(xk-grid_x,amp_gauss,width)
        res_t=f1*f2 #mulitplication of 2 functions
        # integral = sum(res_t)
        integral = np.trapz( y=list(res_t), x=list(grid_x) ) #evaluating the integral
        res_f.extend([integral]) 
    return ( y0 + np.array(res_f) )

# =============================================================================
# def dd(x,x0,y0,amp_gauss,width,xc,amp_exp1,tau1,amp_exp2,tau2):
#     return custom_double_exp_hevi(x,amp_exp1,tau1,amp_exp2,tau2,x0)*custom_gauss(x,amp_gauss,width,xc)
# 
# def custom_conv2(x,x0,y0,amp_gauss,width,amp_exp1,tau1,amp_exp2,tau2):
#     res_f = [] #final convoluted function 
#     for xk in x: #
#         integral, err = quad(dd, xk-1500, xk+1500, args=(x0,y0,amp_gauss,width,xk,amp_exp1,tau1,amp_exp2,tau2)) #evaluating the integral
#         res_f.extend([integral]) 
#     return ( y0 + np.array(res_f) )
# =============================================================================

def cc(r0, x, rxn, D, sigma):
    Omega0 = 1 - ( rxn * special.erfc( (r0 - rxn) / np.sqrt(4*D*x) ) / r0)
    f = 0.14* Omega0 * np.exp(- r0**2 / (2*sigma**2)) * 4 * np.pi * r0**2 / np.sqrt(8 * np.pi**3 * sigma**6)
    return f

def diffusion(x, r0, rxn, D, sigma):
    Omega = []
    for i in x:
        Omega.append(quad(func=cc, a=rxn, b=np.inf, args=(i, rxn, D, sigma))[0])
    return Omega

def diffusion_conv_an(x,x0,y0,amp_gauss,width,amp_diff,rxn,D,sigma):
    grid_x = []
    grid_x = [ np.linspace(i-1500, i+1500, 601) for i in x ]
    grid_x = np.unique(grid_x)
    Omega = []
    for i in grid_x:
        if (i-x0) > 0:
            tg = 0.5 * sigma**2 / D
            Omegap = special.erfc(rxn / np.sqrt(4*D*tg)) + special.erfc(np.sqrt((i-x0)*rxn**2/(4*D*tg*(i-x0+tg)))) * (rxn * np.exp(-rxn**2/ (4*D*(i-x0+tg))) / np.sqrt(np.pi*D*(i-x0+tg))) 
            Omega.append( amp_diff * Omegap)
        else:
            Omega.append( 0 )
    Gaussian = [custom_gauss(i,amp_gauss,width) for i in np.linspace(-1500, 1500, 601)]
    integral = []
    for i in x:
        index = int(np.where(grid_x==i)[0])
        f1 = Omega[index-300 : index+301]
        f2 = Gaussian
        res = np.array(f1) * np.array(f2) #mulitplication of 2 functions
        integral.append( np.trapz( y=list(res), x=list(np.linspace(i-1500, i+1500, 601)) )) #evaluating the integral
    return y0 - np.array(integral)

def diffusion_conv(x,x0,y0,amp_gauss,width,amp_diff,rxn,D,sigma):
    grid_x = []
    grid_x = [ np.linspace(i-1500, i+1500, 601) for i in x ]
    grid_x = np.unique(grid_x)
    Omega = []
    grid_r0 = np.linspace(rxn,100,1000)
    for i in grid_x:
        if (i-x0) > 0:
            Omega0 = 1 - ( rxn * special.erfc( (grid_r0 - rxn) / np.sqrt(4*D*(i-x0)) ) / grid_r0)
            # Omega0p = amp_diff * Omega0 * np.exp(- grid_r0**2 / (2*sigma**2)) * 4 * np.pi * grid_r0**2 / np.sqrt(8 * np.pi**3 * sigma**6)
            Omega0p =  Omega0 * np.exp(- grid_r0**2 / (2*sigma**2)) * 4 * np.pi * grid_r0**2 / np.sqrt(8 * np.pi**3 * sigma**6)
            Omega.append( amp_diff * np.trapz(y = list(Omega0p), x=list(grid_r0)) )
        else:
            Omega.append( 0 )
    Gaussian = [custom_gauss(i,amp_gauss,width) for i in np.linspace(-1500, 1500, 601)]
    integral = []
    for i in x:
        index = int(np.where(grid_x==i)[0])
        f1 = Omega[index-300 : index+301]
        f2 = Gaussian
        res = np.array(f1) * np.array(f2) #mulitplication of 2 functions
        integral.append( np.trapz( y=list(res), x=list(np.linspace(i-1500, i+1500, 601)) )) #evaluating the integral
    return y0 + np.array(integral)

def diffusion_dihalide_conv(x,x0,y0,amp_gauss,width,amp_diff,rxn,D,sigma,amp_exp1,tau1,amp_exp2,tau2):
    grid_x = []
    grid_x = [ np.linspace(i-1500, i+1500, 601) for i in x ]
    grid_x = np.unique(grid_x)
    Omega = []
    grid_r0 = np.linspace(rxn,100,100)
    for i in grid_x:
        if (i-x0) > 0:
            Omega0 = 1 - ( rxn * special.erfc( (grid_r0 - rxn) / np.sqrt(4*D*(i-x0)) ) / grid_r0)
            # Omega0p = amp_diff * Omega0 * np.exp(- grid_r0**2 / (2*sigma**2)) * 4 * np.pi * grid_r0**2 / np.sqrt(8 * np.pi**3 * sigma**6)
            Omega0p = amp_diff * Omega0 * np.exp(- grid_r0**2 / (2*sigma**2)) * 4 * np.pi * grid_r0**2 / np.sqrt(8 * np.pi**3 * sigma**6)
            Omega.append( np.trapz(y = list(Omega0p), x=list(grid_r0)) )
        else:
            Omega.append( float(0) )

    dihalide = []
    for i in grid_x:
        if (i-x0) > 0:
            dihalide.append( (amp_exp1*np.exp(-i/tau1)) + (amp_exp2*(1 - np.exp(-i/tau2))) )
        else:
            dihalide.append( float(0) )
    
    diff_exp = [x + y for x, y in zip(Omega, dihalide)]
    Gaussian = [custom_gauss(i,amp_gauss,width) for i in np.linspace(-1500, 1500, 601)]
    integral = []
    for i in x:
        index = int(np.where(grid_x==i)[0])
        f1 = diff_exp[index-300 : index+301]
        f2 = Gaussian
        res = np.array(f1) * np.array(f2) #mulitplication of 2 functions
        integral.append( np.trapz( y=list(res), x=list(np.linspace(i-1500, i+1500, 601)) )) #evaluating the integral
    return y0 + np.array(integral)

RunNumber = np.array([200]) 
Runs = RunNumber

#Data directory and directory where to save the results
# Directory = 'C:/Users/nurekeye/Desktop/Projects/SACLA_01-2024/DataAnalysis/'  + str(int(RunNumber[0])) + '/'
# Save_Directory = Directory

# Create empty dictionaries to fill them with Pandas DataFrames, each key corresponds to a run
data = {} #timing tool corrected
datau = {} #uncorrected
df_t = pd.DataFrame
ds = pd.Series()
n=0

#load the data. Error appears if you have either Runs0 or Runs1 uncommented, but not both of them. That's intednded, ignore
for i in Runs:
    Directory = 'C:/Users/nurekeye/Desktop/Projects/SACLA_01-2024/DataAnalysis/2024_06_07/' # + str(i) + '/'
    Save_Directory = Directory
    # data[str(i)] = pd.read_csv(Directory+str(i)+'_25fs_0.csv', delimiter=',').replace(' ',np.nan).astype(float)
    data[str(i)] = pd.read_csv(Directory + 'EdgeDiffMax_200nm_averaged.csv', delimiter=',').replace(' ',np.nan).astype(float)

    # df = pd.read_csv(Directory+str(i)+'_25fs_0.csv', delimiter=',').replace(' ',np.nan).astype(float)
    # ds = pd.concat([df,ds])
    # n+=1

# data_ave = {1:}

#Set the model with lmfit
#Create empty dictionaries to fill with fit results
fit_res = {}
fit_report = {}
fit_range_u=1000000 #Upper limit of fitting range in fs, lower limit hasn't been used so far
fit_range_l=-1000

#Fitting itself. Standard deviation is used as weights.
#Common Levenbergâ€“Marquardt algorithm didn't work well, and among 20 different algorithms
#"differential evolution" method was the one with the best results, also it didn't take forever
for k in Runs:
    baseline = np.mean(data[str(k)].TFY_on[(data[str(k)].Delays_on<-500) & (data[str(k)].Delays_on>-1000)])#np.nanmean( data[str(k)].TFY_off )
    # y_axis = np.array(data[str(k)].TFY_on[(~np.isnan(data[str(k)]).any(axis=1))&(data[str(k)].Delays_on<fit_range_u)] - data[str(k)].TFY_off[(~np.isnan(data[str(k)]).any(axis=1))&(data[str(k)].Delays_on<fit_range_u)])
    y_axis = np.array(data[str(k)].TFY_on[(data[str(k)].Delays_on<fit_range_u) & (data[str(k)].Delays_on>fit_range_l) & (data[str(k)].TFY_on_std!=0)] - baseline)
    x_axis = np.array(data[str(k)].Delays_on[(data[str(k)].Delays_on<fit_range_u) & (data[str(k)].Delays_on>fit_range_l) & (data[str(k)].TFY_on_std!=0)])
    x_axis = x_axis.astype(int)
    stddev = np.array(data[str(k)].TFY_on_std[(data[str(k)].Delays_on<fit_range_u) & (data[str(k)].Delays_on>fit_range_l) & (data[str(k)].TFY_on_std!=0)])
    # stddev = np.array(data[str(k)].TFY_on_std[(data[str(k)].Delays_on<fit_range_u) & (data[str(k)].Delays_on>fit_range_l) & (data[str(k)].TFY_on_std!=0)]) / np.sqrt(np.array(data[str(k)].N_values_on[(data[str(k)].Delays_on<fit_range_u) & (data[str(k)].Delays_on>fit_range_l) & (data[str(k)].TFY_on_std!=0)]))

    mid_value = np.mean( y_axis[(300<x_axis) & (x_axis<700)] )/2
    list_a = y_axis[x_axis<500]
    mid_value_real = list_a[min(range(len(list_a)), key=lambda i: abs(list_a[i]-mid_value))]
    t0 = x_axis[y_axis == mid_value_real]
    t0 = float(t0)
    amp_exp0 = float(abs(mid_value*2))
    
# =============================================================================
#     gmodel = lf.Model(custom_conv)
#     params = lf.create_params( x0=dict(value=t0, vary=True, min=-200, max=500), #Time zero in fs
#                           y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
#                           amp_gauss=dict(value=1, vary=False, min=0.1, max=2), #Gaussian amplitude. Keep at 1 and vary=False, it means that amplitude of the fitted function is almost equal to the amplitude of the exponent
#                           width=dict(value=150, vary=True, min=100, max=500), #Gaussian width
#                           amp_exp=dict(value=amp_exp0, vary=True, min=0.001, max=0.2), #Exponent amplitude in a.u.
#                           tau=dict(value=19486, vary=True, min=1000, max=900000) ) #Exponent lifetime in fs
# =============================================================================
    
# =============================================================================
#     gmodel = lf.Model(custom_conv2)
#     params = lf.create_params( x0=dict(value=t0+20, vary=True, min=-200, max=500), #Time zero in fs
#                           y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
#                           amp_gauss=dict(value=1, vary=False, min=0.1, max=2), #Gaussian amplitude. Keep at 1 and vary=False, it means that amplitude of the fitted function is almost equal to the amplitude of the exponent
#                           width=dict(value=300, vary=True, min=100, max=500), #Gaussian width
#                           amp_exp1=dict(value=amp_exp0/2, vary=True, min=0.001, max=0.2), #Exponent amplitude in a.u.
#                           tau1=dict(value=19486, vary=True, min=10000, max=50000), #Exponent lifetime in fs
#                           amp_exp2=dict(value=amp_exp0/2, vary=True, min=0.001, max=0.2), #Exponent amplitude in a.u.
#                           tau2=dict(value=200000, vary=True, min=10000) ) #Exponent lifetime in fs
# =============================================================================
    
# =============================================================================
#     gmodel = lf.Model(custom_errfunc)
#     params = lf.create_params( x0=dict(value=100, vary=True, min=-200, max=500), #Time zero in fs
#                           y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
#                           a=dict(value=0.0386, vary=True, min=0.01, max=0.2), #Error function amplitude in a.u.
#                           g=dict(value=237, vary=True, min=100, max=500)) #Error function width in ps
# =============================================================================
        
# =============================================================================
#     gmodel = lf.Model(diffusion)
#     params = lf.create_params( r0=dict(value=10, vary=True, min=4), 
#                               rxn=dict(value=4, vary=False, min=0), 
#                               D=dict(value=10, vary=True, min=0), 
#                               sigma=dict(value=20, vary=True, min=0) )
# =============================================================================
    
# =============================================================================
#     gmodel = lf.Model(diffusion_conv)
#     params = lf.create_params( x0=dict(value=-100, vary=False, min=-200, max=500), #Time zero in fs
#                               y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
#                               amp_gauss=dict(value=1, vary=False, min=0.1, max=2), #Gaussian amplitude. Keep at 1 and vary=False, it means that amplitude of the fitted function is almost equal to the amplitude of the exponent
#                               width=dict(value=160, vary=False, min=100, max=500), #Gaussian width
#                               amp_diff=dict(value=0.008, vary=True, min=0.001), 
#                               # r0=dict(value=10, vary=True, min=4), 
#                               rxn=dict(value=5, vary=False, min=0), 
#                               D=dict(value=5.6*10**-4, vary=False, min=0), #Diffusion coefficient
#                               sigma=dict(value=4.64, vary=True, max=9) )
# =============================================================================
    
    gmodel = lf.Model(diffusion_conv_an)
    params = lf.create_params( x0=dict(value=40, vary=True, min=-200, max=500), #Time zero in fs
                              y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
                              amp_gauss=dict(value=1, vary=False, min=0.1, max=2), #Gaussian amplitude. Keep at 1 and vary=False, it means that amplitude of the fitted function is almost equal to the amplitude of the exponent
                              width=dict(value=160, vary=True, min=100, max=500), #Gaussian width
                              amp_diff=dict(value=0.003, vary=True, min=0.001, max=1), 
                              # r0=dict(value=10, vary=True, min=4), 
                              rxn=dict(value=5, vary=False, min=0.1, max=10), 
                              D=dict(value=5.6*10**-4, vary=False, min=0.00001, max=1), #Diffusion coefficient
                              sigma=dict(value=4.64, vary=True, min=0.1, max=20) )
    
# =============================================================================
#     gmodel = lf.Model(diffusion_dihalide_conv)
#     params = lf.create_params( x0=dict(value=-100, vary=False, min=-200, max=500), #Time zero in fs
#                               y0=dict(value=0, vary=False, min=-0.1, max=0.1), #Background level in a.u., should be zero since LaserOFF is subtracted, hence, vary=False
#                               amp_gauss=dict(value=1, vary=False, min=0.1, max=2), #Gaussian amplitude. Keep at 1 and vary=False, it means that amplitude of the fitted function is almost equal to the amplitude of the exponent
#                               width=dict(value=400, vary=False, min=100, max=500), #Gaussian width
#                               amp_diff=dict(value=0.008, vary=True, min=0.001), 
#                               # r0=dict(value=10, vary=True, min=4), 
#                               rxn=dict(value=5, vary=False, min=0), 
#                               D=dict(value=5.6*10**-4, vary=False, min=0), #Diffusion coefficient
#                               sigma=dict(value=4.64, vary=True, max=6),
#                               amp_exp1=dict(value=0.0, vary=False, min=0.001, max=0.2), #Exponent amplitude in a.u.
#                               tau1=dict(value=10000000, vary=False, min=10000, max=50000000), #Exponent lifetime in fs
#                               amp_exp2=dict(value=0.00, vary=False, min=0.0001, max=0.2), #Exponent amplitude in a.u.
#                               tau2=dict(value=1000000, vary=False, min=10000) ) #Exponent lifetime in fs                              
# =============================================================================
        
    
    result = gmodel.fit(y_axis, params=params, x=x_axis, 
                        # weights = 1/stddev,
                        method = 'leastsq')
    fit_res[str(k)] = result #save fit results in internal lmfit format
    fit_report[str(k)] = result.fit_report() #save fit report
    # lf.model.save_modelresult(fit_res[str(k)], Save_Directory+EnergyXray+EnergyLaser+PolarisationLaser+'/'+str(k) + EnergyLaser + '.sav') #saving fit results in internal lmfit format in .sav file for 2.9 uJ

# =============================================================================
#     #Plotting the fit results.    
#     plt.figure(str(k),figsize=[16,8], dpi=200)
#     plt.plot(x_axis, y_axis, '.', label='data')
#     plt.plot(x_axis, fit_res[str(k)].init_fit, '--', label='initial fit')
#     plt.plot(x_axis, fit_res[str(k)].best_fit, '-', label='best fit')
#     plt.legend(loc='upper right')
#     plt.xlim([min(x_axis)-max(x_axis), max(x_axis)])
#     plt.ylabel('Intensity (a.u.)')
#     plt.xlabel('Delay (fs)')
#     plt.text(min(x_axis)-max(x_axis), min(y_axis), s=result.fit_report(), fontsize=7)
# =============================================================================
    
    figs, axes = plt.subplots(2,1, sharex=True, height_ratios=[5,1], num=k, figsize=[16,8], dpi=200)
    figs.subplots_adjust(hspace=0)
    # axes[0].errorbar(x_axis, y_axis, yerr=stddev, fmt='.', label='data')
    axes[0].plot(x_axis, y_axis, '.', label='data')
    axes[0].plot(x_axis, fit_res[str(k)].init_fit, '--', label='initial fit')
    axes[0].plot(x_axis, fit_res[str(k)].best_fit, '-', label='best fit')
    axes[0].legend(loc='upper right')
    axes[0].set_ylabel('Intensity (a.u.)')
    axes[0].text(min(x_axis)-max(x_axis), min(y_axis), s=fit_res[str(k)].fit_report(), fontsize=7)
    axes[0].text(0, min(y_axis), 'Average Ejection Distance = ' + str(fit_res[str(k)].best_values['sigma']*np.sqrt(8/np.pi)), fontsize=7)
    axes[1].plot(x_axis, fit_res[str(k)].residual)
    # axes[1].set_ylabel('Resid')
    axes[1].set_xlim([min(x_axis)-max(x_axis), max(x_axis)])
    axes[1].set_xlabel('Delay (fs)')

    mng = plt.get_current_fig_manager()
    mng.window.showMaximized()
    # plt.savefig(Save_Directory +'/' +str(k) + '_fit.png',dpi=300) #saving figures in .png file for 2.9 uJ
    print(fit_res[str(k)].values)

    fig, axes = plt.subplots(1,1, num=k*2, dpi=200)
    comps = fit_res[str(k)].eval_components(x=x_axis)
    dely = fit_res[str(k)].eval_uncertainty(sigma=3)
    axes.plot(x_axis, y_axis, '.', markersize=3, label='data')
    axes.plot(x_axis, fit_res[str(k)].best_fit, '-', label='best fit')
    axes.fill_between(x_axis, fit_res[str(k)].best_fit-dely, fit_res[str(k)].best_fit+dely,
                            color="#C5C9C7", label=r'3-$\sigma$ band')
    axes.set_title('data, best-fit, and uncertainty band')
    axes.legend()
    # plt.savefig(Save_Directory +'/' +str(k) + '_fit2.png',dpi=300) #saving figures in .png file for 2.9 uJ
    
    aa=fit_res[str(k)].best_fit